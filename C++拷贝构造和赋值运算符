总结:
拷贝构造函数和赋值运算符的行为比较相似，却产生不同的结果；拷贝构造函数使用已有的对象创建一个新的对象，赋值运算符是将一个对象的值复制给另一个已存在的对象。区分是调用拷贝构造函数还是赋值运算符，主要是否有新的对象产生。
关于深拷贝和浅拷贝。当类有指针成员或有动态分配空间，都应实现自定义的拷贝构造函数。提供了拷贝构造函数，最后也实现赋值运算符。

***************************************************************************************************************************************
1拷贝构造函数和赋值运算符:
在默认情况下, 编译器会自动的隐式生成一个拷贝构造函数和赋值运算符.但是用户可以使用delete来指定不生成拷贝构造函数和赋值运算符,这个的对象就不能通过值传递
也不能通过赋值运算.


class Person
{
public:
      Person(const Person &p) = delete;
      Person& operator=(const Person &p) = delete;
private:
      int age;
      string name;
}
这个定义显示的删除了拷贝构造函数和赋值运算符,在需要调用拷贝构造函数或者运算符的地方,会提示无法调用该函数,它是已删除的函数.

拷贝构造函数必须以引用的方式传参数.这是因为,在值传递给一个函数的时候,会调用拷贝构造函数生成函数的实参,如果拷贝构造函数参数仍然是以值的方式, 就会无限循环下去知道函数的栈溢出.

拷贝函数和赋值运算符的行为比较相似,都是将一个对象的值赋值给另一个对象,但是其结果却有些不同,拷贝构造函数使用传入对象的值生成一个新的对象的实例,而赋值运算符是将对象的值复制给一个已经存在的实例. 

从名字可以区分,拷贝构造对象是一种构造函数,那么他的功能就是创建一个新的对象实例;赋值运算符是执行某种运算,将一个对象的值赋值给另一个对象(已经存在的).调用的是拷贝构造函数还是赋值运算符,主要是看是与否有新的对象实例产生,如果产生了新的对象实例,那调用的就是拷贝构造函数,如果没有,那就是对已有的对象赋值,调用的就是赋值运算符.

调用拷贝构造函数主要有以下场景:
对象作为函数的参数,以值传递的方式传给函数.
对象作为函数的返回值,以值的方式从函数返回.
使用一个对象给另一个对象初始化.

如:
class Person
{
public:
     Person(){}
     Person(const Person& P)
     {
        cout<<"copy Constructor"<<endl;
     }
     
     Person operator=(const Person& p)
     {
        cout<<"Assign"<<endl;
        return *this;
     }
private:
      int age;
      string name;
}

void f(Person p)
{
    return;
}
Person f1()
{
  Person p;
  return p;
}

int main()
{
    Person P;    
    Person P1 = p;      //1
    Person p2;        
    p2 = p;              //2   
    f(p2);             //3
    
    p2 = f1();           //4
    
    Person P3 = f1();      //5
    
    getchar();
    
    return 0;
}

上述代码显式的定义了一个拷贝构造函数和赋值运算符,然后定义了两个函数:f, 以值的方式传入Person对象; f1(),以值的方式返回Person对象,main()函数运行结果:
Copy Constructor
Assign
Copy Constructor
Copy Construtor
Assign
Copy Consructor

1. 虽然使用了"=",但是实际上使用对象p来创建一个新的对象P1,也就是产生了新的对象,所以调用的是拷贝构造函数
2.首先声明了一个对象P2,然后使用赋值运算符"=",将P的值复制给p2,显然是调用赋值运算符,为一个已经存在的对象赋值
3. 以值的方式将对象p2传入函数内,调用拷贝构造函数构建一个函数f可用的实参.
4.这条语句拷贝构造函数和赋值运算符都调用了,函数f1以值的方式返回一个Person对象,在返回调用拷贝构造函数创建一个临时对象tmp作为返回值;返回后调用赋值运算符将临时对象tmp赋值给p2.
5.按照4的解释,应该是首先调用了拷贝构造函数创建了临时对象,然后再调用拷贝函数使用刚才创建的临时对象创建新的对象P3,也就是调用了两次拷贝构造函数,不过编译器会直接调用拷贝构造函数使用返回值创建了对象p3.

深拷贝与浅拷贝
说道拷贝构造函数,就不得不提深拷贝和浅拷贝,通常,默认生成的拷贝构造函数和赋值运算符,只是简单的进行复制,例如:上面的person类,只有字段int和string两种类型,在拷贝或者赋值时进行值复制创建出来的对象和源对象也是没有任何关联的,对源对象的任何操作都不会影响到拷贝出来的对象.反之,假如Person有一个对象为int*,这时拷贝时还只是进行复制,那么创建出来的Person对象的int* 的值就和源对象的int* 指向了同一个位置, 任何一个对象对该值的修改都是会影响到另一个对象,这就是浅拷贝.

深浅拷贝主要是针对类的指针和动态分配的空间来说的,因为对于指针只是简单的值复制并不能分割两个对象的关联,任何一个对象对于该指针的操作都会影响到另一个对象,这个时候就需要提供自定义的深拷贝的拷贝构造函数,消除这种影响,通常的原则是:
1.含有指针类型的成员或者有动态分配内存的成员都应该提供自定义的拷贝构造函数.
2.提供拷贝构造函数的同时,应该考虑实现自定义的赋值运算符.

对于拷贝构造函数实现需要确定以下几点:
对于值类型的成员函数进行值复制
对于指针和动态分配的空间,在拷贝的时候应该重新分配空间.
对于基类,要调用基类适合的拷贝方法,完成基类拷贝.











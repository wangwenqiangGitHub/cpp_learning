基类的构造函数与析构函数
构造函数不能时虚函数:vptr指针和虚函数表,由于vptr指针指向虚函数表,执行虚函数的时候,会调用vptr指针指向的虚函数的地址.定义一个对象的时候,首先会分配给对象内存空间,
然后调用构造函数来初始化对象.vptr变量是在构造函数中进行初始化的.因为执行虚函数需要通过vptr指针来调用.如果可以定义构造函数为虚函数,那么就会陷入先有鸡还是先有蛋的循环中.

基类的虚构函数为什么必须是虚函数.
如果想要回收对象申请的资源,那么就要调用析构函数,虽然没有显示的调用析构函数,但是编译器会为我们执行析构函数.
如果当我们执行BaseClass *base = new BaseClass();当我们执行delet base 时候,会调用析构函数为我们释放资源.而我们执行BaseClass *sub = new SubClass();
如果BaseClass基类的析构函数不是虚函数的时候,delete sub 对象的时候,只会释放BaseClass基类申请的资源,而不是释放SubClass派生类的资源.
原因是:
    基类指针指向了派生类的对象,而基类中的析构函数是非virtual的,而是虚函数是动态绑定的基础.现在析构函数不是virtual的,因此不会发生动态绑定,而是静态绑定,指针的静态类型
    为基类指针,因此在delete的时候只会调用基类的析构函数,而不会调用派生类的析构函数.这样,在派生类中申请的资源就不会得到释放,就会造成内存的泄露.

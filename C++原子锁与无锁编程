https://zhuanlan.zhihu.com/p/24983412
如何理解互斥锁、条件锁、读写锁以及自旋锁？：https://www.zhihu.com/question/66733477

C++的default和delete
https://www.cnblogs.com/lsgxeva/p/7787438.html
************************************************************************
class Mylock
{
    Mylock(void) = delete;
    Myclock(const Myclock&) = delete;
    Myclock& operator=(const Myclock&) = delete;
    
    std::atomic<bool>& _mutex;
public:
    Myclock(std::atomic<bool>& mutex) : _mutex(mutex)
    {
      while (_mutex.exchange(true))
      {
      }
    }
    ~Mylock(void)
    {
       _mutex.store(false);
    }
}
**************************************************************************
自旋锁是为了实现保护共享资源而提出的一种锁的机制。
对于互斥锁，如果资源已经被占用，资源申请者只能进入睡眠状态。但是自旋锁不会引起调用者睡眠，如果自旋锁已经被别的执行单元保持，调用者就一直循环在那里
看是否自旋锁的保持者已经释放了锁，“自旋”一词都是因此而得名的。
自旋锁的原理：
跟互斥锁一样，一个执行单元要想访问被自旋锁保护的共享资源，必须先得到锁，在访问完共享资源后,必须释放。如果在获取自旋锁时，没有任何执行单元保持该锁，
那么将立即得到锁；如果在获得自旋锁时锁已经有保持者，那么获取锁将自旋在哪里，直到该自旋锁的保持者释放了该锁。由此我们可以看出，自旋锁是一种比较低级
的保护数据结构或代码片段的原始方式，这种锁可能存在两个问题：死锁和过多占用cpu资源。




